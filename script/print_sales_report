#!/usr/bin/env ruby -w
# frozen_string_literal: true

$LOAD_PATH.unshift(File.expand_path(File.join(File.dirname(__FILE__), "..", "lib")))
require 'webconnex_api'

require 'rubygems'
begin
  gem 'activesupport', '~> 7.0'
  require 'active_support/core_ext/object/blank'
rescue Gem::MissingSpecError => e
  $stderr.puts e.message
  $stderr.puts "This test script uses activesupport, but the gem doesn't. Install it manually."
  exit 1
end

require 'optparse'
options = {}
optparse = OptionParser.new do |parser|
  parser.banner = "Usage: #{$0} [options] show_name"

  parser.on("-l", "--[no-]log", "Print full API requests and responses")
  parser.on("-d", "--[no-]details", "Print internal details (Form's ID, eventType, startTime)")
  parser.on("--year YEAR", "Limit results to this calendar year")
end
optparse.parse!(into: options)

if options[:log]
  require 'logger'

  begin
    gem 'http_logger', '~> 0.7'
    require 'http_logger'
  rescue Gem::MissingSpecError => e
    $stderr.puts e.message
    $stderr.puts "This test script uses http_logger, but the gem doesn't. Install it manually."
    exit 1
  end
  HttpLogger.logger = Logger.new($stderr)
  HttpLogger.log_headers = true
  HttpLogger.collapse_body_limit = 0
end

if ENV["WEBCONNEX_API_KEY"].blank?
  raise "Error: environment missing WEBCONNEX_API_KEY"
elsif ENV["WEBCONNEX_API_KEY"] !~ /^[0-9a-f]{32}$/
  raise "Error: WEBCONNEX_API_KEY is set but does not match the expected format"
end
WEBCONNEX_API_KEY = ENV["WEBCONNEX_API_KEY"]

gem 'awesome_print', '~> 1.9'
require 'awesome_print'

def main(options)
  if ARGV.blank?
    raise "Error: specify at least one show name"
  end
  successes = ARGV.map do |show_name|
    print_inventory_report_for_show_name(show_name, year: options[:year], print_internal_details: options[:details])
  end
  exit 0 if successes.all?
  exit 1
end

def print_inventory_report_for_show_name(name, options)
  forms = WebconnexAPI::Form.all
  shows = forms.select { |f| f.name.downcase == name.downcase &&
                             f.published? }.reverse
  if options[:year].present?
    shows = shows.select { |f| options[:year].to_s == f.first_performance_date.year.to_s }
  end

  if shows.none?
    $stderr.puts "No published shows found called #{name.inspect}\n\n"
    return false
  end

  shows.each do |show|
    puts "#{show.name} (#{show.first_performance_date.year})"
    if options[:print_internal_details]
      puts "          Form ID: \033[2;38m#{show.id}\e[0m"
      puts "       Event type: \033[2;38m#{show.event_type}\e[0m"
      puts "      Event start: \033[2;38m#{show.event_start}\e[0m"
      puts "           Status: \033[2;38m#{show.status}\e[0m"
      puts "    Ticket levels: \033[2;38m#{show.ticket_level_names.join(', ')}\e[0m\n\n"
    end

    last_date = nil
    if options[:print_internal_details]
      puts "    Inventory records:"
      show.inventory_records.sort_by { |ir| [ir.name.to_s, ir.key.to_s] }.each do |ir|
        print "    \033[2;38m"; ap ir.to_h.except(:dateCreated, :form_id, :dateUpdated), multiline: false, ruby19_syntax: true; print "\e[0m"
      end
    end
    puts

    total_irs = show.inventory_records.
                  select(&:single_performance_total_sales_record?).
                  sort_by { |total_ir|
                    total_ir.event_has_date_but_no_time? ?
                      total_ir.event_date.to_time :
                      total_ir.event_time
                  }
    total_irs.each do |total_ir|
      next if total_ir.none_sold? && total_ir.past?

      this_date = total_ir.event_date
      if !last_date.nil? && this_date - last_date > 1
        puts "\n\n"
      elsif !last_date.nil? && this_date != last_date
        puts
      end
      if last_date.nil? || last_date != this_date
        print this_date.strftime("    %a, %b %e at ")
      elsif last_date == this_date
        print "                   "
      end

      print total_ir.event_time.strftime("%l:%M%P: ")
      puts "#{show.tickets_for_event_date(total_ir.event_time).count.to_s.rjust(total_ir.quantity.to_s.length)} / #{total_ir.quantity}"
      last_date = this_date
    end

    if show.single?
      total_ir = show.inventory_records.find(&:overall_capacity_record?)
      this_date = show.event_start
      print this_date.strftime("    %a, %b %e at %l:%M%P: ")
      puts "#{show.tickets_for_event_date(show.event_start).count.to_s.rjust(total_ir.quantity.to_s.length)} / #{total_ir.quantity}"
    end

    puts "\n\n"
    past_percent_sold     = (show.total_past_tickets_sold.to_f     / show.total_past_tickets_available     * 100).round(1)
    upcoming_percent_sold = (show.total_upcoming_tickets_sold.to_f / show.total_upcoming_tickets_available * 100).round(1)
    total_percent_sold    = (show.total_tickets_sold.to_f          / show.total_tickets_available          * 100).round(1)

    width = show.total_tickets_available.to_s.length
    format_string = "    %13s: %#{width}d / %#{width}d (%.1f%%)"
    puts format_string % ["Past sold",     show.total_past_tickets_sold,     show.total_past_tickets_available,     past_percent_sold]
    puts format_string % ["Upcoming sold", show.total_upcoming_tickets_sold, show.total_upcoming_tickets_available, upcoming_percent_sold]
    puts
    puts format_string % ["Total",         show.total_tickets_sold,          show.total_tickets_available,          total_percent_sold]
    puts "\n\n"
  end
end

main(options)
